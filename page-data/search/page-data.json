{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"왜 자바에서는 상수를 static final로 지정할까? Java에서는 상수표현을 static final로 쓰는 것이 일반적이다.그리고 그렇게 하라고 다들 피드백 해주었다.그렇다면 왜 그래야할까?여태 그냥 그런 가보다~ 하고 상수라면 응당 static final로 써왔는데 문득 의구심이 들었다.\nfinal은 변수가 아닌 상수 값이니 이해하겠는데,왜 하필 …","fields":{"slug":"/static/"},"frontmatter":{"date":"October 27, 2022","title":"Static","tags":["java"]},"rawMarkdownBody":"\n### 왜 자바에서는 상수를 static final로 지정할까?\n\nJava에서는 상수표현을 static final로 쓰는 것이 일반적이다.그리고 그렇게 하라고 다들 피드백 해주었다.그렇다면 왜 그래야할까?여태 그냥 그런 가보다~ 하고 상수라면 응당 static final로 써왔는데 문득 의구심이 들었다.\nfinal은 변수가 아닌 상수 값이니 이해하겠는데,왜 하필 static이어야 할까?\n이번 기회에 static을 정리하며 의문점도 해소하고 깊이있게 공부해보자.\n\n### static 이란?\n\nStatic은 사전적 의미로 ‘고정된’을 뜻한다.고정된 또는 정적 이라는 의미에 맞게 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 고정된 멤버이다.즉, 클래스 로더가 처음 클래스를 method area라는 메모리 영역에 저장할 때 함께 저장한 다는 뜻이다.\n\n### static 관련 메모리\n\n아래는 java가 os에서 할당 받은 메모리 영역이다.(Runtime Data Area)\n\n![Runtime Data Area](static_memory.png)\n우리가 공부할 static 멤버는 methodArea(=Class Area = static Area)에 Class와 함께 저장된다.처음 클래스 정보를 메모리에 저장할 때 함께 저장되는 것이다.\n(참고로 객체는 heap에, 각종 메소드와 변수는 stack에 저장된다)\n\n### static 변수\n\n: 메모리에 고정적으로 할당되어, 프로그램이 종료될 때 해제되는 변수이다.\n\n```java\npublic class Number {\n    static int classNum = 1;\n    int num = 1;\n}\n\npublic static void main(String[] args) {\n    \tNumber number1 = new Number();\n    \tNumber number2 = new Number();\n\n    \tnumber1.classNum++;\n    \tnumber1.num++;\n    \tSystem.out.println(number2.classNum); //결과: 2\n    \tSystem.out.println(number2.num);//결과: 1\n    }\n```\n\n위의 결과 처럼 Number클래스의 인스턴스들은 해당 classNum이라는 정적변수를 함께 공유하고 있고,각 인스턴스들의 필드값인 num은 각 힙영역에서 값을 달리 가지고 있다.\n\n### static 메소드\n\n:static 메소드 역시 메모리에 고정적로 할당되는 메소드이다.  \n때문에 별도의 인스턴스 생성없이 사용가능하며,객체에서의 호출 또한 가능하지만 지양된다고 한다.\n\n```java\n    public class ResultView {\n        static void printStatic() {\n            System.out.println(\"이것이 static 이다!\");\n        }\n\n        void print(){\n            System.out.println(\"인스턴스 너를 원해!\");\n        }\n    }\n\n    public static void main(String[] args) {\n        ResultView.printStatic();\n\n        ResultView resultView = new ResultView();\n        resultView.print();\n    }\n```\n\n### 결론\n\nstatic을 공부해 보았으니 다시 본론으로 넘어와 보자.그렇다면 왜 자바에서는 상수를 static final로 지정하는 것이 일반적일까?우선 변수가 아닌 상수이므로 final로 지정해준다.이건 이미 공부 전에도 추측 가능한 부분이었다.그렇다면 static은 왜 지정해 주는가? 해당 상수는 클래스 내에서 사용될 예정이고 변하지 않는 값이다.그런데 굳이 우리가 인스턴스를 만들때마다 heap영역에 해당 변수 데이터를 새롭게 저장할 필요가 있을까?이것은 굉장히 비효율적으로 보인다. 그렇기에 static으로 해당 상수를 heap영역이 아닌 메소드 영역에 처음 1번 저장하고 필요할 때마다 사용하는 것이다.  \n그렇게 나는 또 하나 배워간다..\n\n### 참고\n\n- https://mangkyu.tistory.com/47?category=872426\n- https://coding-factory.tistory.com/524\n- https://asfirstalways.tistory.com/158\n"},{"excerpt":"Junit5 란? JUnit5는 자바 프로그래밍 언어용 유닛 테스트 프레임 워크로 자바8이상부터 사용가능하다. 5버전은 이전 버전과 달리 (JUnitPlatform + JUnitJupiter + JUnitVintage)로 구성되어 있다. JunitPlatform: JUnit 플랫폼은 JVM에서 테스트 프레임워크를 시작하기 위한 기반 역할을 한다.또 Tes…","fields":{"slug":"/junit5/"},"frontmatter":{"date":"October 25, 2022","title":"Junit5","tags":["junit5","java"]},"rawMarkdownBody":"\n## Junit5 란?\n\nJUnit5는 자바 프로그래밍 언어용 유닛 테스트 프레임 워크로 자바8이상부터 사용가능하다.  \n5버전은 이전 버전과 달리 (JUnitPlatform + JUnitJupiter + JUnitVintage)로 구성되어 있다.\n\n- **JunitPlatform**: JUnit 플랫폼은 JVM에서 테스트 프레임워크를 시작하기 위한 기반 역할을 한다.또 TestEngine(인터페이스) 플랫폼에서 실행되는 테스트 API를 정의하여 주고,이를 바탕으로 만든 사용자 테스트 코드를 실행 가능하도록 해준다.(jUnit platfrom 엔진 제공)\n\n- **jUnitJupiter**: JUnit Jupiter 는 JUnit 5에서 테스트 및 확장을 작성하기 위한 프로그래밍 모델 과 확장 모델 의 조합이다.\n\n- **JunitVintage**: JUnit 3 및 JUnit 4 기반 테스트를 실행 하기 위한 를 제공합니다.\n\n## 어노테이션\n\n- @Test : 메서드가 테스트 메서드임을 나타냅니다.\n- @ParameterizedTest : 메서드가 매개 변수가 있는 테스트임을 나타냅니다.\n- @DisplayName : 테스트 클래스 또는 테스트 메서드에 대한 사용자 지정 이름을 설정합니다.\n- @BeforeEach : 모든 테스트 메소드 실행 전에 실행되는 메소드입니다.\n- @AfterEach : 모든 테스트 메소드 실행이 끝나면 실행되는 메소드입니다.\n- @Disable : 테스트 클래스나 테스트 메소드를 사용하지 않도록 할 때 사용됩니다.\n- @Timeout : 주어진 시간안에 실행을 못할 경우 실패하도록 하는데 사용됩니다.\n\n\\* **더 많이 알고싶다면** : https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations\n\n## @Parameterized Tests\n\n#### @ValueSource\n\n```java\n@ParameterizedTest\n@ValueSource(strings = { \"racecar\", \"radar\", \"able was I ere I saw elba\" })\nvoid palindromes(String candidate) {\n    assertTrue(StringUtils.isPalindrome(candidate));\n}\n\n@ParameterizedTest\n@ValueSource(ints = { 1, 2, 3 })\nvoid testWithValueSource(int argument) {\n    assertTrue(argument > 0 && argument < 4);\n}\n```\n\n#### @NullSource, @EmptySource\n\n```java\n@ParameterizedTest\n@NullSource\n@EmptySource\n//@NullAndEmptySource 위의 두개 합친 것도 가능\n//@ValueSource(strings = { \" \", \"   \", \"\\t\", \"\\n\" })\nvoid nullEmptyAndBlankStrings(String text) {\n    assertTrue(text == null || text.trim().isEmpty());\n}\n\n```\n\n#### @EnumSource\n\n```java\n@ParameterizedTest\n@EnumSource(ChronoUnit.class)\nvoid testWithEnumSource(TemporalUnit unit) {\n    assertNotNull(unit);\n}\n```\n\n#### @MethodSource\n\n@MethodSource테스트 클래스 또는 외부 클래스의 하나 이상의 팩토리 메소드를 참조할 수 있다.\n\n```java\n@ParameterizedTest\n@MethodSource(\"stringProvider\")\nvoid testWithExplicitLocalMethodSource(String argument) {\n    assertNotNull(argument);\n}\n\nstatic Stream<String> stringProvider() {\n    return Stream.of(\"apple\", \"banana\");\n}\n\n// =================================================\n\n@ParameterizedTest\n@MethodSource(\"range\")\nvoid testWithRangeMethodSource(int argument) {\n    assertNotEquals(9, argument);\n}\n\nstatic IntStream range() {\n    return IntStream.range(0, 20).skip(10);\n}\n```\n\n팩토리 메소드 이름을 명시적으로 제공하지 않으면 @MethodSourceJUnit Jupiter는 규칙에 따라 현재 메소드와 동일한 이름을 가진 팩토리 메소드를 검색한다.\n\n```java\n@ParameterizedTest\n@MethodSource\nvoid testWithDefaultLocalMethodSource(String argument) {\n    assertNotNull(argument);\n}\n\nstatic Stream<String> testWithDefaultLocalMethodSource() {\n    return Stream.of(\"apple\", \"banana\");\n}\n\n```\n\n**매개변수가 여러개일 경우**\n\n```java\n@ParameterizedTest\n@MethodSource(\"stringIntAndListProvider\")\nvoid testWithMultiArgMethodSource(String str, int num, List<String> list) {\n    assertEquals(5, str.length());\n    assertTrue(num >=1 && num <=2);\n    assertEquals(2, list.size());\n}\n\nstatic Stream<Arguments> stringIntAndListProvider() {\n    return Stream.of(\n        arguments(\"apple\", 1, Arrays.asList(\"a\", \"b\")),\n        arguments(\"lemon\", 2, Arrays.asList(\"x\", \"y\"))\n    );\n}\n```\n\n#### @CsvSource\n\n인수 목록을 쉼표로 구분된 값(즉, CSV 리터럴)으로 표현한다.  \n기본 구분자는 쉼표( ,)이지만 'delimiter' 속성을 설정하여 다른 문자를 사용할 수 있다.\n\n```java\n\n@ParameterizedTest\n@CsvSource(value = {\"1:true\", \"2:true\", \"3:true\", \"4:false\",\"5:false\"}, delimiter = ':')\nvoid set_contains_true_false(int element, boolean expected) {\n    if (expected) {\n        System.out.println(element); //결과 1, 2, 3\n        assertTrue(element <= 5); //테스트 통과..\n    }\n}\n\n```\n\n## 참조\n\n- https://junit.org/junit5/docs/current/user-guide/#writing-tests-parameterized-tests\n"},{"excerpt":"Enum 이란? enum은 열거형(enumerated type)이라고 부르며,\n서로 연관된 상수들의 집합이다. Enum의 사용 이유 그렇다면 왜 Enum을 사용할까?\n여러 상수 정의 방법들을 통해 우리는 enum의 등장 배경과 사용 이유를 알 수 있다. 상수 정의 방법(Enum의 등장 배경) 1) 단순 변수명 우선 우리는 단순한 변수명으로 상수들을 만들어…","fields":{"slug":"/Enum/"},"frontmatter":{"date":"October 23, 2022","title":"Enum","tags":["java"]},"rawMarkdownBody":"\n## Enum 이란?\n\nenum은 열거형(enumerated type)이라고 부르며,\n서로 연관된 상수들의 집합이다.\n\n## Enum의 사용 이유\n\n그렇다면 왜 Enum을 사용할까?\n여러 상수 정의 방법들을 통해 우리는 enum의 등장 배경과 사용 이유를 알 수 있다.\n\n### 상수 정의 방법(Enum의 등장 배경)\n\n#### 1) 단순 변수명\n\n```java\n    private static final int APPLE = 1;\n    private static final int PEACH = 2;\n    private static final int BANANA = 3;\n\n    public static void main(String[] args) {\n        int type = APPLE;\n\n        switch (type){\n            case APPLE:\n                System.out.println(\"apple!\");\n                break;\n            case PEACH:\n                System.out.println(\"peach!\");\n                break;\n            case BANANA:\n                System.out.println(\"banana!\");\n                break;\n        }\n    }\n```\n\n우선 우리는 단순한 변수명으로 상수들을 만들어 보았다.\n하지만 만약 여기서 company 데이터타입으로 google과 apple 변수를 추가하면 어떻게 될까?\napple이라는 변수명이 겹치기 때문에 컴파일 에러가 발생할 것이다.\n이럴경우 우리는 접두어를 사용할 수도 있다.\n\n```java\n    private static final int FRUIT_APPLE = 1;\n    private static final int FRUIT_PEACH = 2;\n    private static final int FRUIT_BANANA = 3;\n\n    private static final int COMPANY_GOOGLE = 1;\n    private static final int COMPANY_APPLE = 2;\n    private static final int COMPANY_SAMSUNG = 3;\n```\n\n컴파일 에러는 해결하였지만,코드가 지저분해 졌다.만약 다른 데이터 타입이 더 추가된다면 가독성면에서는 점점 더 나빠질 것이다.\n그래서 다른 방법으로 인터페이스를 사용하는 경우도 있는데 그것을 사용해 보자.\n\n#### 2) 인터페이스\n\n```java\ninterface FRUIT{\n    public static final int APPLE = 1;\n    public static final int PEACH = 2;\n    public static final int BANANA = 3;\n}\ninterface COMPANY{\n    public static final int APPLE = 1;\n    public static final int GOOGLE = 2;\n    public static final int SAMSUNG = 3;\n}\npublic class Main {\n    public static void main(String[] args) {\n        int type = FRUIT.APPLE;\n\n        switch (type){\n            case FRUIT.APPLE:\n                System.out.println(\"apple!\");\n                break;\n            case FRUIT.PEACH:\n                System.out.println(\"peach!\");\n                break;\n            case FRUIT.BANANA:\n                System.out.println(\"banana!\");\n                break;\n        }\n    }\n}\n```\n\n인터페이스를 사용하니 이전과 비교해 볼 떄 상대적으로 가독성이 좋아졌다. 하지만 만약 아래의 코드가 추가된다면 어떻게 될까?\n\n```java\nif(FRUIT.APPLE == COMPANY.APPLE){\n            System.out.println(\"어라? 이게 비교가 되면 안되는데..\");\n        }\n```\n\n우리의 처음 설계목적은 FRUIT 데이터 타입과 COMPANY 데이터 타입이 전혀 다른 것이었다.\n하지만 위의 경우,비교가 가능하여 자칫 의도하지 않은 결과를 초래할 수도 있다.우리는 안정성을 고려하여 이러한 경우 컴파일 에러를 발생시키고 싶다.\n\n#### 3) 클래스\n\n```java\nclass FRUIT{\n    public static final FRUIT APPLE = new FRUIT();\n    public static final FRUIT PEACH = new FRUIT();\n    public static final FRUIT BANANA = new FRUIT();\n}\n\nclass COMPANY{\n    public static final COMPANY GOOGLE = new COMPANY();\n    public static final COMPANY APPLE = new COMPANY();\n    public static final COMPANY SAMSUNG = new COMPANY();\n}\n```\n\n위 코드 처럼 클래스 형태로 각각의 데이터 타입을 만들어 준다면,비교하는 과정에서 컴파일 에러를 발생시킬 수 있다.\n하지만 switch문에서 컴파일 에러가 발생한다.\n그 이유는 switch문에서 사용할 수 있는 데이터 타입이 다소 제한적이기 때문이다.\n(byte,short,char,int,enum,String,Character,Byte,Short,Integer)\n\n![class방식 error](class_error.png)\n\n#### 4) Enum\n\n```java\n/*\nclass FRUIT{\n    public static final FRUIT APPLE = new FRUIT();\n    public static final FRUIT PEACH = new FRUIT();\n    public static final FRUIT BANANA = new FRUIT();\n}\n */\nenum FRUIT{\n    APPLE, PEACH, BANANA;\n}\nenum COMPANY{\n    APPLE, GOOGLE, SAMSUNG;\n}\npublic class Main {\n    public static void main(String[] args) {\n        FRUIT type = FRUIT.APPLE;\n\n        switch (type){\n            case APPLE:\n                System.out.println(\"apple!\");\n                break;\n            case PEACH:\n                System.out.println(\"peach!\");\n                break;\n            case BANANA:\n                System.out.println(\"banana!\");\n                break;\n        }\n    }\n}\n```\n\n드디어 enum 방식으로 변경하여 보았다. 이전 보다 훨씬 간결하게 원하는 바를 달성할 수 있었다.\n사실 위 주석과 새로 추가한 FRUIT enum의 코드의 의미는 같다.그렇다 enum은 클래스이다.위 주석과 같은 클래스 형식의 패턴이 enum 등장 이전까지 사람들이 일반적으로 사용하던 상수 표현 방식이다.그래서 java측에서 이를 문법적으로 지원한 것이 바로 enum인 것이다.(약속)\n\n## Enum 사용 및 특징\n\n### 생성자\n\n```java\nenum FRUIT{\n    APPLE, PEACH, BANANA;\n    FRUIT(){\n        System.out.println(\"Call constructor \"+ this);\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        FRUIT type = FRUIT.APPLE;\n        switch (type){\n            case APPLE:\n                System.out.println(\"apple!\");\n                break;\n            case PEACH:\n                System.out.println(\"peach!\");\n                break;\n            case BANANA:\n                System.out.println(\"banana!\");\n                break;\n        }\n    }\n```\n\n![실행 결과](constructor_result.png)\n\n클래스형태이기에 위 코드처럼 각 인스턴스의 생성자가 실행되는 것을 볼 수 있다.\n필드 역시 추가 가능하다.\n\n```java\nenum FRUIT{\n    APPLE(\"red\"), PEACH(\"pink\"), BANANA(\"yellow\");\n    String color;\n    FRUIT(String color){\n        this.color = color;\n        System.out.println(\"Call constructor \"+ this+\", color: \"+this.color);\n    }\n}\n\n```\n\n![필드명 추가 실행 결과](field_result.png)\n\n### 특징\n\nEnum은 클래스이기에 생성자와 필드값 그리고 관련 메서드까지 설정 가능하다.\n하지만 Enum은 고정된 상수값들의 집합이므로 컴파일 타임에 모든 값을 알고 있어야 한다.\n즉,안정성 측면에서 동적으로 값을 정해주거나 변경할 수 없어야 한다는 뜻이다.\n따라서 생성자의 접근제어자는 반드시 private이어야 하며,이는 enum의 인스턴스 생성을 제어하며 외부적으로 사용되기에 싱글톤 방식으로도 볼 수 있다.\n마지막으로, 관련된 상수들을 모아 두는 것은 물론 클래스형태이기에 연관된 메소드나 필드값을 한곳에 저장할 수 있어서 설계 목적 등의 문맥을 담기에도 용이하다.\n\n## 참고 자료\n\n- https://opentutorials.org/module/516/6091\n- https://www.nextree.co.kr/p11686/\n"},{"excerpt":"데브코스에 시작 전.. 사실 데브코스에 들어오기 전,그러니까 합격 메일을 받기 전까지는 해당 과정에 붙을 꺼라고\n감히 상상조차 하지 못했다.\n면접 마지막 떄 '떨어져도 여러분들이 부족한게 아니에요.' 라는 말을 들은 것도 한 몫 했고,\n또 이전에 겪었던 면접 실패에 대한 경험들이 자기방어적으로 작동해서 나도 모르게 기대치를 낮춘 것 같기도 하다.(울지마.…","fields":{"slug":"/1주차/"},"frontmatter":{"date":"October 22, 2022","title":"1주차를 마치고","tags":["회고","devCourse"]},"rawMarkdownBody":"\n## 데브코스에 시작 전..\n\n사실 데브코스에 들어오기 전,그러니까 합격 메일을 받기 전까지는 해당 과정에 붙을 꺼라고\n감히 상상조차 하지 못했다.\n면접 마지막 떄 '떨어져도 여러분들이 부족한게 아니에요.' 라는 말을 들은 것도 한 몫 했고,\n또 이전에 겪었던 면접 실패에 대한 경험들이 자기방어적으로 작동해서 나도 모르게 기대치를 낮춘 것 같기도 하다.(울지마..바보야! 난 정말..ㄱㅊㄴ..)\n\n아무튼..\n그렇게 합격메일을 받고 한 삼일정도는 생각날 때마다 합격 결과를 본 것같다..\n사실 누가보면 좋은 곳에 취업한 것도 아닌데 그게 그렇게 좋은가?라고 할 수도 있다.\n하지만 당시의 나는 계속된 취업 실패로 좌절감을 느꼈고,또 기존에 세웠던 계획들에 대한 의구심을 느낄 때 쯤이었다.그 때 마침 데브코스의 합격 메일이 온 것이다.암울했던 상황도 상황이었지만,기대하지 않았던 결과였기에 더욱더 기뻤던 것 같다.\n어쩌면 내게 주어지는 몇 안되는 기회다 싶은 생각이 들기도 하였다.\n\n데브코스가 시작하기 전까지 한 열흘정도의 기간이 남아 있었다.\n해당 기간동안 많이 늘어지고 게으르게 보냈는데 그게 많이 후회된다..ㅜㅜ\n'빡세게 시작하기 전에 우선 리프레쉬 하자' 라는 자기합리화도 있었고,\n또 들뜬마음에 마치 취업이 확정된 것 마냥 굴었던 것 같기도 하다.. 하하;;\n\n## 데브코스 에서의 첫 주를 마치고..\n\n그렇게 시간이 흘러 오리엔테이션 날이 되었다.\n나는 설레이는 마음에 동기들을 확인하랴, 설명을 들으랴 매우 바빴다.ㅋㅋ\n자격지심이었는지 모두들 개발 고수처럼 느껴졌고,시작하기 전 게으르게 보냈던 시간들이 스쳐지나가며\n나 자신을 자책하기도 했다.ㅜㅜ(허허 이 기특한녀석.. 시간을 그리 보내다니.. )\n그렇게 OT를 마무리하고 즐거운 주말을 보낸 뒤 데브 코스가 시작되었다.\n\n첫 1,2주는 자바 관련한 강의들이었다.\n사실 아는 내용과 모르는 내용들이 더러 섞여 있었지만,자바에 대해 좀 더 깊이있게 알게 되었던 것만은 확실했다.또 코스 전반적으로 하루 학습한 것을 기록으로 남기는 TIL을 권장하고 있었다.\n머리속 내용을 설명하려고 글로 적다보니 강의내용보다 좀 더 찾아보게 되었고,\n배운 내용을 확실히 내 것으로 만드는 느낌이 들어서 시작하길 잘했다고 생각했다.\nTIL을 작성하는 곳을 gastby를 통해 github.io로 만들었는데 여기서 애좀 먹었다..\n(바보같은 나의모습..스읍..하..)\n\n또 게더에 모여서 다같이 이야기도 하고,오늘 할 일들을 팀원들과 스크럼 하면서 이야기도 하니 혼자 할 때보다 의지도 더 생기고 힘도 나는 것 같았다.\n\n아,실시간 세션도 진행하였는데 유튜브에서만 보던 유명한 분들이 오셔서 설명해주니 콘서트에 온 것 같았다.ㅋㅋ 아는 체하고 싶었지만 그 분들은 나를 처음 보는 것이었기에 흔들려더 손을 반대쪽 손으로 낚아채는데 애좀 먹었다;;ㅋ\n\n그 밖에 중간중간 멘토님들의 팀면담,그리고 개별 면담을 진행하며 고민상담도 해주셨다.\n엄~청 친절하셔서 놀랐고,다들 왜이렇게 말을 잘하시는지 신기했다.ㅋㅋ\n(대애박 ~ 사건? 이렇게 하는 거 맞나?ㅋㅋㅋㅋ)\n\n처음 시작하고 1,2주가 여유로운 기간이라고 하셨는데 미션도 해야하고 할일이 많다ㅋㅋ\n3주차부터 몇배는 더 힘들어지고 어려워진다는데 큰일이다 진짜ㅋㅋ\n그래도 어제의 나와 비교해보았을 때 매일매일이 성장함을 느끼고 있어서 만족한다.\n이번 주말을 알차게 보내야 겠다.\n"},{"excerpt":"1.Stream 이란? 스트림이란 순차 또는 병렬 집계 작업을 지원하는 데이터의 흐름이자 반복자 이다.\n(A sequence of elements supporting sequential and parallel aggregate operations.)\n이러한 개념을 토대로 나온 StreamAPI는 java에서도 함수형프로그래밍을 가능하도록 하기위해 나온 오…","fields":{"slug":"/stream/"},"frontmatter":{"date":"October 21, 2022","title":"Stream","tags":["java"]},"rawMarkdownBody":"\n## 1.Stream 이란?\n\n스트림이란 순차 또는 병렬 집계 작업을 지원하는 데이터의 흐름이자 반복자 이다.\n(A sequence of elements supporting sequential and parallel aggregate operations.)\n이러한 개념을 토대로 나온 StreamAPI는 java에서도 함수형프로그래밍을 가능하도록 하기위해 나온 오퍼레이션들의 모임이라고\n할 수 있다.\n\n## 2. 특징\n\n그렇다면 스트림의 특징은 무엇이 있을까?\n\n### 스트림은 원본 데이터를 변경하지 않는다.\n\n원본의 데이터를 조회하여 원본의 데이터가 아닌 별도의 요소들로 Stream을 생성한다.\n그렇기 때문에 원본의 데이터로부터 읽기만 할 뿐,정렬이나 필터링 등의 작업은 별도의 Stream 요소들에서 처리가 된다.\n\n### 내부 반복으로 작업을 처리한다.\n\nfor이나 while문과는 다르게 반복문법을 메소드 내부에 숨기고 있어 코드가 간결해진다.\n\n### 스트림으로 처리하는 데이터는 오직 한번만 처리한다.(일회성)\n\nInterator와 같이 처리하고 지나가는 것이기에 재사용이 불가능하다.\n그렇기 때문에 다시 사용하려면 다시 stream을 생성하여야한다.\n\n### 중개 오퍼레이션은 Lazy Evolution.\n\nLazy Evoution이란 실제로 필요해지는 경우에 연산을 시작하는 것인데 Stream의 중개 오퍼레이션이 이에 해당한다.\n\n아래는 그 예시이다.\n\n```java\n        List<String> names = new ArrayList<>();\n        names.add(\"a\");\n        names.add(\"bb\");\n        names.add(\"ccc\");\n        names.add(\"dddd\");\n        names.add(\"eeeee\");\n        names.add(\"ffffff\");\n\n        Integer[] result = names.stream()\n                .map(s -> {\n                    System.out.println(s);\n                    return s.length();\n                })\n                .filter(i -> {\n                    System.out.println(\"filter!\");\n                    return (i % 2) == 0;\n                })\n                .limit(2)\n                .toArray(Integer[]::new);\n\n```\n\n```\na\nfilter!\nbb\nfilter!\nccc\nfilter!\ndddd\nfilter!\n```\n\n위의 코드 결과 처럼 lazy하게 하나씩 실행되며 조건에 만족한다면 뒤의 나머지 값들은 실행되지 않는다.\n또 다른 에시를 보자.\n\n```java\nList<String> names = new ArrayList<>();\nnames.add(\"aaa\");\nnames.add(\"bbb\");\nnames.add(\"ccc\");\nnames.add(\"ddd\");\n\nnames.stream().map(s -> {\n    System.out.println(\"s\");\n    return s.toUpperCase();\n})\n```\n\n해당 코드의 print는 실행되지 않는다.\n왜냐하면 위에서 언급한 것과 같이 중개오퍼레이션은 종료오퍼레이션을 만나야 실행되기때문이다.\n우리는 이러한 구조를 스트림 파이프라인이라고 부른다.\n\n## 3. 스트림 파이프라인\n\n파이프라인이란 컴퓨터 과학에서 한 데이터 처리 단계의 출력이 다음 단계의 입력으로 이어지는 형태로 연결된 구조를 말한다.\n스트림은 중개오퍼레이션과 종료오퍼레이션을 가지고 이러한 파이프라인을 형성한다.\n여기서 스트림파이프 라인의 특징은 종료오퍼레이션이 시작되기 전까지 중개오퍼레이션은 지연(lazy)된다는 것이다.\n종료오퍼레이션이 시작하면 비로소 컬렉션에서 요소가 하나씩 중개오퍼레이션에서 처리되고 종료오퍼레이션까지 오게 된다.\n\n- 0 또는 다수의 중개 오퍼레이션 (intermediate operation)과 한개의 종료 오퍼레이션 (terminal operation)으로 구성한다.\n- 스트림의 데이터 소스는 오직 터미널 오퍼네이션을 실행할 때에만 처리한다.\n\n### 중개 오퍼레이션\n\n- Stream을 리턴한다.\n- Stateless / Stateful 오퍼레이션으로 더 상세하게 구분할 수도 있다.\n  (대부분은 Stateless지만,distinct나 sorted처럼 이전 이전 소스 데이터를 참조해야 하는 경우는Stateful 오퍼레이션.)\n- filter, map, limit, skip, sorted, ...\n\n### 종료 오퍼레이션\n\n- Stream을 리턴하지 않는다.\n- collect, allMatch, count, forEach, min, max, ...\n\n### 참고\n\n- https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html\n\n- https://mangkyu.tistory.com/112\n"},{"excerpt":"1. 포스트 추가하기  경로에 새로운 마크다운 파일을 생성하여 여러분의 글을 추가할 수 있습니다. 1-1. 포스트 파일 구조 새로운 문서를 추가하는 방법에는 두가지가 있습니다. 첫번째는 디렉토리 없이 문서를 생성하는 방법입니다. 만약 여러분이 Javascript 에 관한 문서를 생성한다면,  파일을  디렉토리에 추가할 수 있습니다. 두번째 방법은 먼저 디…","fields":{"slug":"/writing-guide-kr/"},"frontmatter":{"date":"April 03, 2021","title":"작성 가이드","tags":["writing-guide"]},"rawMarkdownBody":"\n## 1. 포스트 추가하기\n\n`contents/post` 경로에 새로운 마크다운 파일을 생성하여 여러분의 글을 추가할 수 있습니다.\n\n### 1-1. 포스트 파일 구조\n\n새로운 문서를 추가하는 방법에는 두가지가 있습니다. 첫번째는 디렉토리 없이 문서를 생성하는 방법입니다. 만약 여러분이 Javascript 에 관한 문서를 생성한다면, `about-javascript.md` 파일을 `contents/posts` 디렉토리에 추가할 수 있습니다.\n\n두번째 방법은 먼저 디렉토리를 생성한 뒤, 디렉토리 안에 `index.md` 파일을 추가하는 것 입니다. 이 방법은 문서 내에 여러 이미지 파일 등 부수적인 파일 여러개가 포함되었을 때 유용합니다.\n\n첫번째 방법으로 생성한 파일명이나, 두번째 방법으로 생성한 디렉토리 이름은 웹사이트에서 고유의 주소를 갖습니다. `https://siteURL/about-javascript` 와 같이요.\n\n### 1-2. Frontmatter\n\n마크다운은 문서의 메타데이터인 Frontmatter 라 불리는 정보를 가지고 있습니다.\n\n```\n---\ntitle: \"🤔 3. 작성 가이드\"\ndescription: \"어떻게 글을 작성하고 추가할까요?\"\ndate: 2021-04-03\nupdate: 2021-04-03\ntags:\n  - hoodie\n  - writing-guide\nseries: \"gatsby-starter-hoodie 로 블로그 시작하기\"\n---\n```\n\n위는 지금 여러분이 읽고 있는 문서의 Frontmatter 입니다. `title` 과 `date` 는 필수 값입니다. 띄어쓰기를 포함된 문자열을 입력할 때에는 따옴표로 감싸는 것을 추천합니다.\n\n### 1-3. 마크다운 작성하기\n\n만약 Frontmatter 까지 작성했다면, 여러분은 그 아래에 마크다운 문서를 작성하면 됩니다. gatsby-starter-hoodie 는 대부분의 마크다운 문법을 지원합니다. 마크다운 작성 방법을 알고 싶다면, Github 의 [Mastering Markdown](https://guides.github.com/features/mastering-markdown/) 문서를 참고하세요.\n\n## 2. 코드 하이라이팅 & Katex\n\n### 2-1. 코드 하이라이팅\n\nPrism.JS 에 기반한 코드 하이라이팅이 제공됩니다.\n\n#### 예시\n\nJavascript\n\n```javascript\nconsole.log(\"Hello, world!\")\n```\n\nPython\n\n```python\nprint(\"Hello, world!\")\n```\n\n그 외 더 많은 언어를 제공합니다. 제공되는 언어를 확인하고 싶다면, [Prism.js 웹사이트](https://prismjs.com/) 를 참고하세요.\n\n### 2-2. Katex\n\nKatex 문법을 지원하여 복잡한 수식도 쉽게 표현할 수 있습니다.\n\n#### 인라인 모드\n\n$$E = m c^{2}$$\n\n#### 블럭 모드\n\n$$\n\\int_{0}^{\\infty} f(x) dx\n$$\n\n## 3. 글에 이미지 추가하기\n\n상대경로를 이용하여 쉽게 이미지를 추가할 수 있습니다. 디렉토리를 생성하고 그 안에 `index.md` 를 추가하여, 글을 추가하는 방법으로 작성해야 이미지 관리가 쉽습니다.\n\n![샘플 이미지 캡션](sample-image.jpg)\n\n이미지는 Lazy Loading 으로 로드되어, 빠른 초기 문서 로딩 속도를 확보할 수 있습니다.\n\n> ⚠ 이미지의 모든 확장자는 소문자여야합니다.\n\n## 4. 태그\n\n![](tag-example.jpg)\n\nFrontmatter 의 태그를 통해 쉽게 문서를 분류하고 검색할 수 있습니다. 여러분의 모든 태그는 `https://siteUrl/tags` 경로에서 확인하고, 검색할 수 있습니다.\n\n## 5. 시리즈\n\n![](series-example.jpg)\n\n여러분이 연관된 여러개의 문서를 작성할 때 시리즈를 사용할 수 있습니다. Frontmatter 에 작성된 시리즈가 같은 문서끼리 묶여 문서 상단에 리스트로 표시됩니다. 시리즈는 일련의 순서가 있는 문서들을 작성할 때 유용하게 사용할 수 있습니다. 시리즈는 문서의 작성 날짜 순서대로 정렬됩니다.\n\n현재 문서는 `gatsby-starter-hoodie 로 블로그 시작하기` 라는 시리즈로 설정되어 있습니다.\n"}]}},"pageContext":{}},"staticQueryHashes":[]}